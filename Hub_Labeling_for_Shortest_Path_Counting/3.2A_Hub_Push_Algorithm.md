构造算法为每个节点求得![](http://latex.codecogs.com/svg.latex?L_{\le}(\cdot))



#### 算法HP-SPC



**Definition:**

![](http://latex.codecogs.com/svg.latex?T^c_{\le}(v):) 其中的元组![](http://latex.codecogs.com/svg.latex?(w,C_{v,w}))满足![](http://latex.codecogs.com/svg.latex?C_{v,w}) 等于![](http://latex.codecogs.com/svg.latex?P_{v,w}), w is a conical hub of v

![](http://latex.codecogs.com/svg.latex?T^{nc}_{\le}(v):) 其中元组![](http://latex.codecogs.com/svg.latex?(w,C_{v,w}))满足![](http://latex.codecogs.com/svg.latex?C_{v,w}) 是![](http://latex.codecogs.com/svg.latex?P_{v,w})的一个真子集, w is a non-conical hub of v

当![](http://latex.codecogs.com/svg.latex?w)是![](http://latex.codecogs.com/svg.latex?P_{v,w})所涉及的所有节点![](http://latex.codecogs.com/svg.latex?Q_{v,w})中rank最高的节点时，![](http://latex.codecogs.com/svg.latex?(w,C_{v,w})\in T^c_{\le}(v))， 反之，![](http://latex.codecogs.com/svg.latex?(w,C_{v,w})\in T^{nc}_{\le}(v))



**算法大致思路：**

按照rank降序依次遍历每个节点w作为hub，在去除了rank高于w的节点![](http://latex.codecogs.com/svg.latex?H_w)之后的图![](http://latex.codecogs.com/svg.latex?G_w)上，进行bfs，在bfs的过程中求得w到v的最短距离![](http://latex.codecogs.com/svg.latex?D[v])（不是原图G，而是图![](http://latex.codecogs.com/svg.latex?G_w)），令![](http://latex.codecogs.com/svg.latex?d)为经过已经加入到![](http://latex.codecogs.com/svg.latex?L_{\le}(w))和![](http://latex.codecogs.com/svg.latex?L_{\le}(v))的hub的$w,v$之间的最短距离(![](http://latex.codecogs.com/svg.latex?d=\min_{w^{'}\in L_{\le}^c(w)\cap L_{\le}^c{(v)}}sd(w,w^{'})+sd(v,w^{'})))，如果![](http://latex.codecogs.com/svg.latex?d=D[v])，则将w加入![](http://latex.codecogs.com/svg.latex?L_{\le}^{nc}(v))；如果![](http://latex.codecogs.com/svg.latex?d>D[v])，则将w加入![](http://latex.codecogs.com/svg.latex?L^{c}_{\le}(v))，并且更新v的邻点![](http://latex.codecogs.com/svg.latex?v^{'})到w的最短距离![](http://latex.codecogs.com/svg.latex?D[v^{'}])





**算法解析：**

1.如果![](http://latex.codecogs.com/svg.latex?d)

可从w到达v：

![](http://latex.codecogs.com/svg.latex?D[v])是在去除![](http://latex.codecogs.com/svg.latex?H_w)之后的图上求得的![](http://latex.codecogs.com/svg.latex?w,v)之间的最短距离，该最短距离可能大于![](http://latex.codecogs.com/svg.latex?v,w)在原图上的最短距离，此时，就对应![](http://latex.codecogs.com/svg.latex?d<D[v])的情况，也就说明，w必须经过rank高于w的节点才能到达v，那么![](http://latex.codecogs.com/svg.latex?w)既不属于![](http://latex.codecogs.com/svg.latex?L_{\le}^{c}(v))，也不属于![](http://latex.codecogs.com/svg.latex?L_{\le}^{nc}(v))



<img src="3.2A_Hub_Push_Algorithm.assets/image-20221108205829187.png" alt="image-20221108205829187" style="zoom:50%;" />



从w无法到达v：

自然，![](http://latex.codecogs.com/svg.latex?w)既不属于![](http://latex.codecogs.com/svg.latex?L_{\le}^{c}(v))，也不属于![](http://latex.codecogs.com/svg.latex?L_{\le}^{nc}(v))

<img src="3.2A_Hub_Push_Algorithm.assets/image-20221108210219879.png" alt="image-20221108210219879" style="zoom:50%;" />





2.如果![](http://latex.codecogs.com/svg.latex?d==D[v])，说明在当前图![](http://latex.codecogs.com/svg.latex?G_w)上存在某些![](http://latex.codecogs.com/svg.latex?w,v)在原图上的最短路径，也就是说，![](http://latex.codecogs.com/svg.latex?w,v)在原图上的最短路径中，有一部分路径不经过rank高于w的节点，这种情况，![](http://latex.codecogs.com/svg.latex?w)属于![](http://latex.codecogs.com/svg.latex?L_{\le}^{nc}(v))

<img src="3.2A_Hub_Push_Algorithm.assets/image-20221108210911855.png" alt="image-20221108210911855" style="zoom:50%;" />



3.如果![](http://latex.codecogs.com/svg.latex?d>D[v])，说明![](http://latex.codecogs.com/svg.latex?w,v)之间的最短路都不经过rank高于w的节点，这种情况，![](http://latex.codecogs.com/svg.latex?w)属于![](http://latex.codecogs.com/svg.latex?L_{\le}^{c}(v))

<img src="3.2A_Hub_Push_Algorithm.assets/image-20221108211103163.png" alt="image-20221108211103163" style="zoom:50%;" />





伪代码：

![](http://latex.codecogs.com/svg.latex?D[v]:)在图![](http://latex.codecogs.com/svg.latex?G_w)上![](http://latex.codecogs.com/svg.latex?w)到![](http://latex.codecogs.com/svg.latex?v)的最短路距离

![](http://latex.codecogs.com/svg.latex?C[v]:)在图![](http://latex.codecogs.com/svg.latex?G_w)上![](http://latex.codecogs.com/svg.latex?w)到![](http://latex.codecogs.com/svg.latex?v)的最短路数量

![image-20221108182020664](3.2A_Hub_Push_Algorithm.assets/image-20221108182020664.png)







